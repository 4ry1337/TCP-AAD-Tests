\section{Formal Properties}

We specify nine temporal logic properties to verify correctness of TCP acknowledgment mechanisms. Properties are categorized as safety, liveness, or algorithm-specific.

\subsection{Linear Temporal Logic}

Linear Temporal Logic (LTL)~\cite{pnueli1977temporal} extends propositional logic with temporal operators:

\begin{itemize}
    \item $\square$ (\textit{always}): Property holds at all future states
    \item $\Diamond$ (\textit{eventually}): Property holds at some future state
    \item $\bigcirc$ (\textit{next}): Property holds in the next state
    \item $U$ (\textit{until}): First property holds until second becomes true
\end{itemize}

SPIN uses the syntax: \texttt{[]} for $\square$, \texttt{<>} for $\Diamond$, \texttt{->} for implication.

\subsection{TCP Basic Properties}

\subsubsection{P1: All Segments Acknowledged}

\begin{verbatim}
ltl all_acked {
    <>(segments_sent == segments_acked &&
       segments_sent == MAX_SEGMENTS)
}
\end{verbatim}

\textbf{Category}: Liveness \\
\textbf{Meaning}: Eventually, all sent segments are acknowledged and transmission completes. \\
\textbf{Rationale}: Fundamental TCP reliability requirement.

\subsubsection{P2: Progress}

\begin{verbatim}
ltl progress {
    []<>(segments_sent > 0 -> segments_acked > 0)
}
\end{verbatim}

\textbf{Category}: Liveness \\
\textbf{Meaning}: Always, if segments are sent, eventually some are acknowledged. \\
\textbf{Rationale}: Ensures no deadlock or starvation.

\subsection{TCP Default DACK Properties}

\subsubsection{P3: Maximum Delayed Segments}

\begin{verbatim}
ltl max_two_delayed {
    [](delayed_count <= MAX_DELAYED_SEGS)
}
\end{verbatim}

\textbf{Category}: Safety \\
\textbf{Meaning}: Always, at most 2 segments are delayed before ACK. \\
\textbf{Rationale}: RFC 1122 compliance—must ACK every second segment.

\subsubsection{P4: Eventual Acknowledgment (DACK)}

\begin{verbatim}
ltl eventual_ack_dack {
    <>(segments_sent > 0 -> segments_acked == segments_sent)
}
\end{verbatim}

\textbf{Category}: Liveness \\
\textbf{Meaning}: Eventually, all sent segments are acknowledged. \\
\textbf{Rationale}: With delayed ACKs, verify timeouts prevent indefinite delay.

\subsubsection{P5: Connection Completion (DACK)}

\begin{verbatim}
ltl completion {
    <>(segments_sent == MAX_SEGMENTS &&
       segments_acked == MAX_SEGMENTS)
}
\end{verbatim}

\textbf{Category}: Correctness \\
\textbf{Meaning}: Eventually, the connection completes with all segments transferred. \\
\textbf{Rationale}: Ensures delayed ACK logic doesn't prevent session termination.

\subsection{TCP-AAD Properties}

\subsubsection{P6: ATO Bounded}

\begin{verbatim}
ltl ato_bounded {
    [](ato <= MAX_ATO)
}
\end{verbatim}

\textbf{Category}: Safety \\
\textbf{Meaning}: Always, the adaptive timeout does not exceed 500ms. \\
\textbf{Rationale}: Ensures RFC 1122 compliance despite adaptive calculation. Critical for preventing excessive delays.

\subsubsection{P7: Eventual Acknowledgment (AAD)}

\begin{verbatim}
ltl eventual_ack_aad {
    <>(segments_sent > 0 -> segments_acked == segments_sent)
}
\end{verbatim}

\textbf{Category}: Liveness \\
\textbf{Meaning}: Eventually, all sent segments are acknowledged. \\
\textbf{Rationale}: Adaptive timeouts must not prevent eventual acknowledgment.

\subsubsection{P8: IAT Minimum Valid}

\begin{verbatim}
ltl iat_min_valid {
    [](iat_min > 0 && iat_min <= MAX_IAT)
}
\end{verbatim}

\textbf{Category}: Safety \\
\textbf{Meaning}: Always, IAT\_min is within valid bounds. \\
\textbf{Rationale}: Ensures tracking logic doesn't overflow or underflow. \\
\textbf{Note}: Verified in full mode (computationally expensive).

\subsubsection{P9: ACK Progress}

\begin{verbatim}
ltl acks_progress {
    []<>(acks_sent > 0)
}
\end{verbatim}

\textbf{Category}: Liveness \\
\textbf{Meaning}: Always, eventually an ACK is sent. \\
\textbf{Rationale}: System does not stall—ACKs continue to flow. \\
\textbf{Note}: Verified in full mode.

\subsubsection{P10: Adaptive ACKs Used}

\begin{verbatim}
ltl adaptive_used {
    <>(adaptive_acks > 0)
}
\end{verbatim}

\textbf{Category}: Algorithm-specific \\
\textbf{Meaning}: Eventually, at least one ACK uses adaptive timing. \\
\textbf{Rationale}: Verifies TCP-AAD actually engages adaptive behavior (not just fixed timeout).

\subsubsection{P11: IAT Reset Periodic}

\begin{verbatim}
ltl iat_reset {
    []<>(iat_min == MAX_IAT)
}
\end{verbatim}

\textbf{Category}: Algorithm-specific \\
\textbf{Meaning}: Always, eventually IAT\_min is reset to maximum. \\
\textbf{Rationale}: Ensures periodic reset occurs, allowing adaptation to changing conditions. \\
\textbf{Note}: Verified in full mode.

\subsubsection{P12: Connection Completion (AAD)}

\begin{verbatim}
ltl completion_aad {
    <>(segments_sent == MAX_SEGMENTS &&
       segments_acked == MAX_SEGMENTS)
}
\end{verbatim}

\textbf{Category}: Correctness \\
\textbf{Meaning}: Eventually, the connection completes. \\
\textbf{Rationale}: Adaptive logic doesn't break session completion.

\subsection{Property Classification}

Table~\ref{tab:property_classes} categorizes all properties:

\begin{table}[h]
\centering
\caption{Property Classification}
\begin{tabular}{llll}
\hline
\textbf{Property} & \textbf{Type} & \textbf{Model} & \textbf{Mode} \\
\hline
P1: all\_acked & Liveness & Basic & Quick \\
P2: progress & Liveness & Basic & Quick \\
P3: max\_two\_delayed & Safety & DACK & Quick \\
P4: eventual\_ack\_dack & Liveness & DACK & Quick \\
P5: completion & Correctness & DACK & Quick \\
P6: ato\_bounded & Safety & AAD & Quick \\
P7: eventual\_ack\_aad & Liveness & AAD & Quick \\
P8: iat\_min\_valid & Safety & AAD & Full \\
P9: acks\_progress & Liveness & AAD & Full \\
P10: adaptive\_used & Algorithm & AAD & Quick \\
P11: iat\_reset & Algorithm & AAD & Full \\
P12: completion\_aad & Correctness & AAD & Quick \\
\hline
\end{tabular}
\label{tab:property_classes}
\end{table}

Quick mode verifies 9 essential properties (~9 minutes). Full mode adds 3 properties for comprehensive verification (~20-30 minutes).

\subsection{Property Design Rationale}

\subsubsection{Safety Properties}

Safety properties ($\square P$) assert that "nothing bad happens":
\begin{itemize}
    \item \textbf{P3}: Prevents excessive delay (RFC violation)
    \item \textbf{P6}: Prevents timeout overflow (unbounded delay)
    \item \textbf{P8}: Prevents IAT calculation errors
\end{itemize}

Violations produce counter-examples showing the error trace.

\subsubsection{Liveness Properties}

Liveness properties ($\Diamond P$ or $\square\Diamond P$) assert that "something good eventually happens":
\begin{itemize}
    \item \textbf{P1, P4, P7}: Ensure eventual acknowledgment
    \item \textbf{P2, P9}: Ensure progress (no deadlock)
\end{itemize}

SPIN detects liveness violations as acceptance cycles in the never claim.

\subsubsection{Correctness Properties}

Correctness properties verify high-level goals:
\begin{itemize}
    \item \textbf{P5, P12}: Connection completes successfully
\end{itemize}

These combine safety and liveness aspects.

\subsubsection{Algorithm-Specific Properties}

Properties unique to TCP-AAD:
\begin{itemize}
    \item \textbf{P10}: Verifies adaptive behavior actually occurs
    \item \textbf{P11}: Verifies periodic reset mechanism
\end{itemize}

These wouldn't make sense for DACK (no adaptive logic).

\subsection{Property Interdependencies}

Some properties imply others:
\begin{itemize}
    \item P1 (all acknowledged) $\implies$ P2 (progress)
    \item P5 (completion) $\implies$ P4 (eventual ACK)
\end{itemize}

However, we verify all properties independently to:
\begin{enumerate}
    \item Gain confidence through redundancy
    \item Detect subtle bugs that might violate one but not another
    \item Explore different state space regions
\end{enumerate}

This comprehensive property suite provides high assurance of TCP-AAD correctness across multiple dimensions: safety, liveness, and algorithm-specific behavior.
