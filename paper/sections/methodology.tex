\section{Methodology}

This section describes our formal verification approach, including the model checker used, time abstraction strategy, and verification workflow.

\subsection{Verification Tool: SPIN}

We use SPIN 6.5.2~\cite{holzmann1997model}, a widely-used model checker for concurrent systems. SPIN offers several advantages for protocol verification:

\begin{itemize}
    \item \textbf{Promela language}: High-level modeling of concurrent processes with message passing
    \item \textbf{LTL verification}: Native support for Linear Temporal Logic properties
    \item \textbf{Scalability}: Optimizations like partial order reduction and state compression
    \item \textbf{Counter-examples}: Automatic generation of error traces for debugging
\end{itemize}

\subsubsection{Verification Workflow}

Our verification workflow consists of four stages:

\begin{enumerate}
    \item \textbf{Model Specification}: Write Promela model with TCP sender, receiver, and time keeper processes
    \item \textbf{Property Definition}: Specify correctness properties as LTL formulas inline
    \item \textbf{Compilation}: SPIN generates C code for the verifier (\texttt{pan})
    \item \textbf{Verification}: Execute \texttt{pan} to explore state space and check properties
\end{enumerate}

\subsection{Time Abstraction Strategy}

SPIN is an \textit{untimed} model checkerâ€”it does not model continuous time or real-valued clocks. Verifying TCP-AAD requires modeling timeouts and inter-arrival times, which are inherently temporal. We address this through \textit{logical time abstraction}.

\subsubsection{Logical Time Counter}

We introduce a global variable \texttt{logical\_time} that represents abstract time units. A dedicated \texttt{TimeKeeper} process increments this counter:

\begin{verbatim}
active proctype TimeKeeper() {
    do
    :: (logical_time < MAX_TIME) ->
        atomic { logical_time++; }
    :: (logical_time >= MAX_TIME) -> break;
    od
}
\end{verbatim}

We define \textbf{1 logical time unit = 1 millisecond}, providing sufficient granularity for TCP acknowledgment delays (typical range: 0.2ms - 500ms).

\subsubsection{Timer Implementation}

ACK timers are implemented using state variables:

\begin{itemize}
    \item \texttt{timer\_pending}: Boolean flag indicating if timer is active
    \item \texttt{timer\_expiry}: Logical time when timer expires
\end{itemize}

When a segment arrives without triggering immediate ACK, the receiver sets:

\begin{verbatim}
timer_expiry = logical_time + ato;
timer_pending = true;
\end{verbatim}

Timer expiration is checked non-deterministically:

\begin{verbatim}
:: (timer_pending && logical_time >= timer_expiry) ->
    // Send ACK
    timer_pending = false;
\end{verbatim}

This approach models timer behavior without requiring real-time semantics.

\subsubsection{IAT Calculation}

Inter-arrival time is computed as the difference in logical time:

\begin{verbatim}
iat_curr = logical_time - last_packet_time;
\end{verbatim}

This abstraction preserves relative timing relationships essential for TCP-AAD's adaptive behavior.

\subsubsection{Integer Arithmetic for ATO}

TCP-AAD's ATO formula uses floating-point arithmetic:

\[
ATO = (IAT_{min} \times 0.75 + IAT_{curr} \times 0.25) \times 1.5
\]

Since SPIN does not support floating-point, we reformulate using integer arithmetic:

\begin{align}
ATO &= \frac{IAT_{min} \times 0.75 + IAT_{curr} \times 0.25}{1} \times 1.5 \\
    &= \frac{IAT_{min} \times 3 + IAT_{curr}}{4} \times \frac{3}{2} \\
    &\approx \frac{IAT_{min} \times 3 + IAT_{curr}}{4}
\end{align}

We drop the final $\times 1.5$ factor and use:

\begin{verbatim}
ato = (iat_min * 3 + iat_curr) / 4;
if (ato > MAX_ATO) { ato = MAX_ATO; }
\end{verbatim}

This preserves the qualitative adaptive behavior while ensuring bounded ATO values.

\subsection{Model Parameterization}

We use bounded model checking with carefully chosen parameters:

\begin{table}[h]
\centering
\caption{Model Parameters}
\begin{tabular}{lcc}
\hline
\textbf{Parameter} & \textbf{Value} & \textbf{Rationale} \\
\hline
MAX\_SEGMENTS & 10 & Balance coverage vs. state space \\
CHANNEL\_SIZE & 20 & Prevent message loss \\
MAX\_ATO & 500 & RFC 1122 maximum \\
MIN\_IAT\_FILTER & 2 & Filter noise (0.2ms) \\
RESET\_PERIOD & 1000 & IAT\_min reset (1 second) \\
MAX\_TIME & 5000 & Simulation bound (5 seconds) \\
\hline
\end{tabular}
\label{tab:parameters}
\end{table}

These parameters are sufficient to explore TCP's behavior across multiple RTTs while keeping state space manageable.

\subsection{State Space Optimization}

To handle large state spaces (67-75 million states), we employ several optimizations:

\subsubsection{Compression}

We compile the verifier with \texttt{-DCOLLAPSE} flag, enabling state vector compression. This reduces memory usage by 4-6\% through efficient encoding of state vectors.

\subsubsection{Memory Limit}

We set \texttt{-DMEMLIM=4096} to allow up to 4GB memory usage, sufficient for our models while preventing system thrashing.

\subsubsection{Atomic Blocks}

Critical sections use \texttt{atomic} blocks to reduce interleaving:

\begin{verbatim}
atomic {
    sender_to_receiver ! DATA(seq_num);
    segments_sent++;
}
\end{verbatim}

This reduces state space without affecting correctness since these operations are logically instantaneous.

\subsection{Verification Automation}

We developed automation scripts to streamline verification:

\begin{itemize}
    \item \texttt{verify\_all.sh}: Runs all verifications, extracts statistics, generates reports
    \item \texttt{analyze\_results.py}: Parses SPIN output, computes metrics, creates comparison tables
\end{itemize}

Automation enables:
\begin{enumerate}
    \item Reproducible experiments
    \item Systematic property verification (9 properties across 3 models)
    \item Easy comparison between DACK and TCP-AAD
\end{enumerate}

\subsection{Validation Against Implementation}

To ensure our models reflect real behavior, we validated against the Linux kernel v6.12.9 TCP-AAD implementation:

\begin{itemize}
    \item Compared state transitions with kernel code paths
    \item Verified ATO calculation matches kernel formula
    \item Checked quick ACK mode behavior
    \item Validated IAT\_min reset logic
\end{itemize}

This validation provides confidence that verified properties hold for the actual implementation, not just the model.
