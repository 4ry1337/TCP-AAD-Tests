/*
 * LTL Properties for TCP DACK and TCP-AAD Verification
 *
 * Property Categories:
 * - Safety Properties (S): Bad things never happen
 * - Liveness Properties (L): Good things eventually happen
 * - Fairness Properties (F): Fair behavior
 * - Correctness Properties (C): Protocol correctness
 *
 * Usage: spin -a -N <property_name> model.pml
 */

/* ===== BASIC TCP PROPERTIES ===== */

/* S1: All sent segments are eventually acknowledged */
ltl all_acked_basic { <>(segments_sent == segments_acked && segments_sent > 0) }

/* S2: No deadlock in communication */
ltl no_deadlock { []<>(segments_sent > 0 -> segments_acked > 0) }

/* S3: ACK sequence numbers are valid */
ltl ack_valid_seq { [](segments_acked <= segments_sent) }


/* ===== DEFAULT DACK PROPERTIES ===== */

/* S4: No more than 2 segments delayed before ACK (RFC 1122) */
ltl max_two_delayed_dack { [](delayed_count <= 2) }

/* S5: All segments eventually acknowledged (DACK) */
ltl eventual_ack_dack { <>(segments_sent > 0 -> segments_acked == segments_sent) }

/* S6: ACK timeout never exceeds 500ms */
ltl timeout_bounded_dack { [](ato <= 500) }

/* L1: ACKs are eventually sent (progress) */
ltl acks_sent_dack { []<>(acks_sent > 0) }

/* L2: Delayed ACKs are used (efficiency) */
ltl delayed_acks_used { <>(delayed_acks > 0) }

/* C1: Connection completes successfully */
ltl completion_dack { <>(segments_sent == 10 && segments_acked == 10) }


/* ===== TCP-AAD SPECIFIC PROPERTIES ===== */

/* S7: ATO never exceeds maximum bound (500ms) */
ltl ato_bounded_aad { [](ato <= 500) }

/* S8: ATO is always positive when set */
ltl ato_positive { [](ato > 0) }

/* S9: IAT_min is valid */
ltl iat_min_valid { [](iat_min > 0) }

/* S10: IAT_curr is non-negative */
ltl iat_curr_valid { [](iat_curr >= 0) }

/* S11: All segments eventually acknowledged (AAD) */
ltl eventual_ack_aad { <>(segments_sent > 0 -> segments_acked == segments_sent) }

/* S12: Delayed count never exceeds maximum */
ltl delayed_bound_aad { [](delayed_count <= 2) }

/* L3: IAT_min is periodically reset (every 1000 time units) */
ltl iat_reset_periodic { []<>(iat_min == 10000) }

/* L4: Adaptive ACKs are used */
ltl adaptive_acks_used { <>(adaptive_acks > 0) }

/* L5: Quick ACK mode is entered when needed */
ltl quick_ack_responsive { []<>(quick_ack_mode || !quick_ack_mode) }

/* L6: Timer is set when segments are delayed */
ltl timer_set_on_delay { [](delayed_count > 0 -> <>timer_pending) }

/* C2: Connection completes (AAD) */
ltl completion_aad { <>(segments_sent == 10 && segments_acked == 10) }

/* C3: Adaptive behavior adapts to IAT changes */
ltl ato_adapts { [](iat_curr > 0 -> <>(ato != 500)) }


/* ===== COMPARATIVE PROPERTIES ===== */

/* These properties compare DACK vs AAD behavior */

/* F1: Both mechanisms eventually ACK all segments */
ltl both_complete { <>(segments_acked == 10) }

/* F2: ACKs are sent with reasonable frequency */
ltl ack_frequency { []<>(acks_sent > 0) }

/* F3: No segment is left unacknowledged indefinitely */
ltl no_starvation { [](segments_sent > segments_acked -> <>segments_acked++) }


/* ===== SAFETY CRITICAL PROPERTIES ===== */

/* S13: No integer overflow in ATO calculation */
ltl no_ato_overflow { [](ato < 32767) }

/* S14: No integer overflow in IAT tracking */
ltl no_iat_overflow { [](iat_curr < 32767 && iat_min < 32767) }

/* S15: Timer expiry is always in the future when set */
ltl timer_future { [](timer_pending -> (timer_expiry > logical_time)) }

/* S16: Logical time monotonically increases */
ltl time_monotonic { [](logical_time >= 0) }


/* ===== LIVENESS CRITICAL PROPERTIES ===== */

/* L7: System always makes progress */
ltl system_progress { []<>(logical_time > 0) }

/* L8: Eventually all work is done */
ltl eventual_completion { <>(connection_active == false) }

/* L9: No infinite loops in ACK processing */
ltl no_ack_loop { []<>(acks_sent < 100) }


/* ===== PROPERTY SELECTION GUIDE ===== */
/*
 * For quick verification (< 1 minute):
 *   - all_acked_basic
 *   - no_deadlock
 *   - max_two_delayed_dack
 *   - ato_bounded_aad
 *
 * For comprehensive safety check (5-10 minutes):
 *   - All S* properties
 *   - no_ato_overflow
 *   - no_iat_overflow
 *   - timer_future
 *
 * For liveness verification (10-30 minutes):
 *   - All L* properties
 *   - eventual_completion
 *   - iat_reset_periodic
 *
 * For comparison study:
 *   - Run both models with:
 *     - both_complete
 *     - ack_frequency
 *     - eventual_ack_dack vs eventual_ack_aad
 *
 * For full verification (1-2 hours):
 *   - All properties above
 *   - Use bitstate hashing for larger state spaces
 */
